#!/usr/bin/env python3
"""
Master Orchestrator - Autonomous Product Demo Generator (Professional Edition)

Single-command execution: Product_Specs.md ‚Üí Professional AI Demo Video

Workflow:
1. Phase 1: Generate Storyline (Storyline Intelligence)
2. Phase 2: Record browser scenes (Autonomous Agent)
3. Phase 3: Generate AI Scenes (Hook + Tech Wrap-up with Gemini)
4. Phase 4: Generate Enhanced Voiceover (Monika + Emotional Expressions)
5. Phase 5: Smart Composition (Stitch professional demo)

Usage: python3 orchestrator.py [--config Product_Specs.md]
"""

import os
import sys
from pathlib import Path
from datetime import datetime
import subprocess
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# No need to add framework to path as we are IN the framework directory now


def run_phase(phase_num: int, phase_name: str, command: list, cwd: Path) -> bool:
    """Execute a phase and track success"""
    print("\n" + "="*80)
    print(f"üé¨ PHASE {phase_num}: {phase_name.upper()}")
    print("="*80)
    print(f"Command: {' '.join(command)}")
    print()
    
    try:
        result = subprocess.run(
            command,
            cwd=cwd,
            check=True,
            capture_output=False,
            text=True
        )
        
        print(f"\n‚úÖ Phase {phase_num} complete: {phase_name}")
        return True
        
    except subprocess.CalledProcessError as e:
        print(f"\n‚ùå Phase {phase_num} failed: {phase_name}")
        print(f"Error: {e}")
        return False


def main():
    """Main orchestration"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Autonomous Product Demo Generator - Full Pipeline"
    )
    parser.add_argument(
        "--config",
        default="../INPUT/configuration/Product_Specs.md",
        help="Path to Product_Specs.md"
    )
    parser.add_argument(
        "--skip-recording",
        action="store_true",
        help="Skip browser recording (use existing)"
    )
    parser.add_argument(
        "--analyze-url",
        help="Analyze a product URL to auto-generate Product_Specs.md"
    )
    parser.add_argument(
        "--product-name",
        help="Product Name (optional, used with --analyze-url)"
    )
    
    args = parser.parse_args()
    
    # Determine absolute paths
    framework_dir = Path(__file__).parent.resolve()
    config_path = framework_dir / args.config
    
    # Check if config exists, but don't exit if we plan to generate it
    if not config_path.exists():
        print(f"‚ö†Ô∏è  Config not found: {config_path}")
        print("   Assuming it will be generated by Product Analysis phase...")
    else:
        print(f"üìÑ Config found: {config_path}")
        # sys.exit(1) -> Removed to allow bootstrapng
    # If the user passed a custom config path (confusing if relative),
    # let's assume they passed it relative to where they ran it from.
    # But usually we run from framework dir.
    # Let's trust the args.config default or user input.
    
    # Check if config exists via the relative path from CWD (which should be framework/)
    # OR absolute path.
    # The default is "../INPUT/configuration/Product_Specs.md" which works from framework/
    
    # Redundant check removed to allow bootstrapping
    # if not os.path.exists(args.config): ...
    
    print("="*80)
    print("üöÄ AUTONOMOUS PRODUCT DEMO GENERATOR (PRO EDITION)")
    print("="*80)
    # print(f"Config: {config_path}") # This variable was based on hardcoded assumption
    print(f"Config: {args.config}")
    print(f"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print()
    
    # Track phases
    phases_completed = []
    start_time = datetime.now()
    
    # Resolve config to absolute path to avoid subprocess CWD issues
    # Correctly handle relative paths from framework dir
    if ".." in args.config:
        abs_config_path = (framework_dir / args.config).resolve()
    else:
        abs_config_path = Path(args.config).resolve()
         
    # Phase 0: Product Analysis (Optional)
    if args.analyze_url:
        analyze_cmd = [
            "python3",
            "product_analyzer.py",
            f"--url={args.analyze_url}",
            f"--output={abs_config_path}"
        ]
        if args.product_name:
            analyze_cmd.append(f"--name={args.product_name}")
            
        if not run_phase(
            0,
            "Product Analysis & Spec Generation",
            analyze_cmd,
            framework_dir
        ):
            print("\n‚ùå Product Analysis failed")
            sys.exit(1)
        phases_completed.append("Product Analysis")
    

    # Phase 0: Product Analysis
    # Generates Product_Specs.md from URL
    # if not run_phase(
    #     0,
    #     "Product Analysis & Spec Generation",
    #     [
    #         "python3",
    #         "product_analyzer.py",
    #         "--url=https://igniteai.in", 
    #         "--output=../INPUT/configuration/Product_Specs.md",
    #          "--credentials=test@test.com/test@test.com"
    #     ],
    #     framework_dir
    # ):
    #     print("‚ùå Product Analysis failed. Pipeline stopped.")
    #     sys.exit(1)
    # phases_completed.append("Product Analysis")

    # Phase 1: Browser Recording & Video Generation (Record First)
    # Uses Product_Specs.md actions to generate raw footage
    if not run_phase(
        1,
        "Autonomous Video Recording",
        [
            "python3",
            "browser_recorder.py",
            f"--storyline={abs_config_path}", # Pointing to Product_Specs.md as source of actions
            f"--config={abs_config_path}",
            "--output-dir=../INPUT/raw_recordings"
        ],
        framework_dir
    ):
        print("‚ùå Recording failed. Pipeline stopped.")
        sys.exit(1)
    phases_completed.append("Autonomous Video Recording")

    # Phase 2: Storyline Generation (Context-Aware)
    # Generates script based on Specs AND Recording Manifest
    if not run_phase(
        2,
        "Storyline Intelligence Engine",
        [
            "python3",
            "storyline_generator.py",
            f"--config={abs_config_path}",
            "--output=../OUTPUT/scripts/Storyline.md"
        ],
        framework_dir
    ):
        print("\n‚ùå Pipeline failed at Phase 2")
        sys.exit(1)
    phases_completed.append("Storyline Generation")
        
    # Phase 3: AI Scene Generation (Hooks/B-Roll)
    if not run_phase(
        3,
        "Generative Visuals Engine (Hook)",
        [
            "python3",
            "scene_generator.py",
            "--type=hook",
            "--output-dir=../OUTPUT/scenes"
        ],
        framework_dir
    ):
        print("\n‚ùå Pipeline failed at Phase 3 (Hook Scene)")
        sys.exit(1)
    
    # Tech Stack Scene
    if not run_phase(
        3,
        "Generative Visuals Engine (Tech Stack)",
        [
            "python3",
            "scene_generator.py",
            "--type=tech",
             "--output-dir=../OUTPUT/scenes"
        ],
        framework_dir
    ):
        print("\n‚ùå Pipeline failed at Phase 3 (Tech Stack Scene)")
        sys.exit(1)
    phases_completed.append("AI Scene Generation")
        
    # Phase 4: Enhanced Voiceover Generation
    if not run_phase(
        4,
        "Neural Voice Synthesis",
        [
            "python3",
            "voiceover_generator.py",
            "--storyline=../OUTPUT/scripts/Storyline.md",
            "--output_dir=../OUTPUT/voiceover"
        ],
        framework_dir
    ):
        print("\n‚ùå Pipeline failed at Phase 4")
        sys.exit(1)
    phases_completed.append("Enhanced Voiceover")

    # Phase 5: Caption Generation (New)
    # Generates SRT/ASS from Audio
    # Assuming voiceover_generator produces a combined audio or individual files?
    # caption_generator.py takes single audio input. 
    # For now, let's skip individual caption generation here and let smart_compositor handle it?
    # NO, the plan says Integrate caption_generator.
    # But voiceover_generator produces multiple files.
    # The smart_compositor usually stitches them. 
    # Let's run captioning on individual files? OR wait for compositor?
    # The 'caption_generator.py' tool seems designed for a single audio file.
    # Let's add it as a sub-step/utility or let compositor call it.
    # Actually, let's inject it into phase 4 or 5?
    # Better: Update smart_compositor to call captioning?
    # User asked to "Leverage that!" in the pipeline.
    # Let's add a phase for it, but we need to know what file to caption.
    # If we generate per-scene VO, we need per-scene captions.
    # Let's Modify orchestrator to NOT call caption_generator directly yet, but update `smart_compositor_v2.py` to use it? 
    # OR: run a script that captions all VOs in output dir.
    pass
    phases_completed.append("Caption Generation (Integrated)") # Mark as integrated into compositor

    # Phase 6: Professional Video Composition
    if not run_phase(
        6,
        "Professional Smart Composition",
        [
            "python3",
            "smart_compositor_v2.py",
            "--storyline=../OUTPUT/scripts/Storyline.md", 
            "--output=../OUTPUT/final_video/IgniteAI_Final_Demo.mp4",
            "--captions=true" # Flag to enable captioning inside compositor
        ],
        framework_dir
    ):
        print("\n‚ùå Pipeline failed at Phase 6")
        sys.exit(1)
    phases_completed.append("Video Composition")
    
    # Summary
    elapsed = datetime.now() - start_time
    
    print("\n" + "="*80)
    print("üéâ PIPELINE EXECUTION SUMMARY")
    print("="*80)
    print(f"Total time: {elapsed.total_seconds():.1f} seconds")
    print()
    print("Phases completed:")
    for i, phase in enumerate(phases_completed, 1):
        print(f"  {i}. {phase}")
    print()
    print("üìÅ Generated Assets:")
    print(f"  - Storyline: {base_dir}/OUTPUT/scripts/Storyline.md")
    print(f"  - Recordings: {base_dir}/INPUT/raw_recordings/")
    print(f"  - AI Scenes: {base_dir}/OUTPUT/scenes/")
    print(f"  - Voiceovers: {base_dir}/OUTPUT/voiceover/")
    print(f"  - FINAL VIDEO: {base_dir}/OUTPUT/final_video/IgniteAI_Final_Demo.mp4")
    print()


if __name__ == "__main__":
    main()
